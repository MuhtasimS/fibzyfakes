This is Fibz. A discord bot written in javascript. I'll paste its readme with its capabilities below. I've set up a local chroma database and what I want to do is to improve it in the following ways: 
- vectorizing and migrating its current memory and storing all future information in a locally hosted chromadb database and the ability to retrieve it
- add storage of more metadata for messages within the vectorized database 
- Have it save relevant context about itself across conversations
Here are some other features I could think to add to it: 
- Context menus & message actions
Right-click ‚Üí ‚ÄúAsk Fibz about this message/file.‚Äù
- Reaction-based controls
React with üîÅ to regenerate, üìé to export, üß† to pin to memory.
- Multi-store memory
messages, self_context, entities, archives (cold).
- Metadata-rich vectors
Store: guild_id, channel_id, user_id, persona, modality, consent, version, tags, latency, token_counts.
- Hybrid search (BM25 + vectors)
- Scheduled compression
Periodically summarize old threads ‚Üí archives with source back-refs.
- Slide & PDF understanding
Chunk by page/slide; attach page numbers in citations.
- Image ‚Äúwho/what/where‚Äù tagging
Extract entities/locations; index as metadata for better recall.
- Metrics & tracing
Prometheus counters: requests, tokens, latency, tool calls, retrieval hit-rate.
- Idempotent upserts
Deterministic IDs (guild:channel:message) to avoid dupes.
- Config hot-reload
Change personas/rules without restarts.
- Export/import
/export thread|channel ‚Üí zip with JSONL + attachments.
- One-command dev
boots bot + Chroma + dashboard via Docker Compose.
- Release notes
Auto-generate CHANGELOG, update ‚ÄúFibz: What‚Äôs new‚Äù command.
- Entity memory graphs
Build a lightweight knowledge graph (people ‚Üî topics ‚Üî files).
- Instruction precedence engine (core > user > server/channel)
Where core personality is prepended to user custom personality which are both prepended to server/channel instructions. In case of clashing instructions, core takes precedence over user, which takes precedence over server/channel. 
- Consent & sharing policy (decision table)
Classify each item as Shareable / Private / Consent-required.
Defaults:
DM content: Private unless user opts in to share.
Channel content: Shareable to same channel/server.
Personal attributes, contact info, health, finances: Consent-required.
I want it to be able to decide what's okay to share and what isn't. If consent-required stuff comes up, I want it to ping the required user and ask for consent.
- Chroma design (no Postgres, per your choice)
Collections: messages, self_context, entities, archives.
Metadata (suggested): guild_id, channel_id, user_id, username, role, modality, reply_to, created_at, tokens, persona, version, consent, tags.
Filters: Always include guild_id and same channel_id for cross-user queries unless policy overrides.
- Retriever quality without ‚Äúfeedback loop‚Äù
Hybrid fuse (optional): quick BM25 (tiny in-proc) + cosine (no extra DB).
Chunking: semantic + size cap (e.g., 800‚Äì1200 tokens), page anchors for PDFs/slides.
Post-retrieve reasoned re-ranking (LLM picks top N) for higher precision.
- Multimodal ingestion
Voice messages ‚Üí Cloud Speech-to-Text; keep audio hash + duration in metadata.
Images/PDFs: OCR (Vision API or Tesseract) + captions; store page/slide numbers.
AV: ffmpeg duration/aid/mid; extract speech tracks when present.
(It can already do most of this)
- ‚ÄúRe-embed‚Äù maintenance command to bump schema versions.
- Graceful Vertex fallbacks (retry/backoff) without adding rate-guard features.
- Observability (lightweight)
Structured logs (JSON) for: prompt id, model, latency, tokens, retrieval hit count, consent path.
/status adds: Chroma doc counts by collection + last embed model version.

That's it for stuff I want to add/improve. Here is a current list of what the bot can do: 
Fibz: A Discord bot leveraging Google Cloud Vertex AI (Gemini 2.5 Pro) for advanced conversation, content understanding, image/video/audio recognition, voice message comprehension, and more ‚Äî with enterprise-grade security and a vastly improved UX.
- **Now powered by 2.5 Gemini Pro!** (via Vertex AI)
- **Uses Google Cloud Vertex AI Platform**
- **Enterprise-grade security and authentication**
- **WAY better user experience and interface**
- **Super duper advanced smart Image/video/audio and file recognition** (supports images, videos, audios, PDFs, docx, pptx; can understand voice messages; full multimodal support; **can‚Äôt write code at the moment**)
- **PERSISTENT, PERMANENT, REFERENCEABLE MEMORY!!!** (Fibz remembers and can look up archives when needed)
- **Can recognize different people within the same conversation!** (multi-user attribution/awareness)
- **Core Identity and Rules** (configurable behavior guardrails)
- **Updated privacy and consent protocol**
- **Personalized personalities!** (per user, channel, or server)
- **Improved and foolproofed button-based UI**
- **Ability to override the 2000 character limit when instructed to** (auto-splitting/attachments)
- **Server and channel-wide chat history** options
- **Admin controls** for blacklisting/whitelisting users
- **Downloadable conversation/message history**
- **Multiple AI tools:** integrated tool use (e.g., Google Search)
- **Status monitoring** (RAM, CPU, and reset timer)

If you want, I can give you a quick rundown of the code formatted and compressed via repomix to make it easier to understand what you're working with too. Here it is:
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been compressed (code blocks are separated by ‚ãÆ---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules, README.md, LICENSE.md, example.env, .gitignore
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ‚ãÆ---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
botManager.js
commands.js
config.js
index.js
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="botManager.js">
dotenv.config();
‚ãÆ----
// --- Core Client and API Initialization ---
// Using new Google GenAI library instead of deprecated @google/generative-ai
export const client = new Client({
‚ãÆ----
// Initialize with new API format that requires apiKey object
export const genAI = new GoogleGenAI({
‚ãÆ----
// --- Concurrency and Request Management ---
export const activeRequests = new Set();
class Mutex {
‚ãÆ----
acquire() {
return new Promise(resolve => {
‚ãÆ----
resolve();
‚ãÆ----
this._queue.push(resolve);
‚ãÆ----
release() {
‚ãÆ----
const nextResolve = this._queue.shift();
nextResolve();
‚ãÆ----
async runExclusive(callback) {
await this.acquire();
‚ãÆ----
return await callback();
‚ãÆ----
this.release();
‚ãÆ----
export const chatHistoryLock = new Mutex();
// --- State and Data Management ---
‚ãÆ----
get chatHistories() {
‚ãÆ----
set chatHistories(v) {
‚ãÆ----
get activeUsersInChannels() {
‚ãÆ----
set activeUsersInChannels(v) {
‚ãÆ----
get customInstructions() {
‚ãÆ----
set customInstructions(v) {
‚ãÆ----
get serverSettings() {
‚ãÆ----
set serverSettings(v) {
‚ãÆ----
get userResponsePreference() {
‚ãÆ----
set userResponsePreference(v) {
‚ãÆ----
get alwaysRespondChannels() {
‚ãÆ----
set alwaysRespondChannels(v) {
‚ãÆ----
get channelWideChatHistory() {
‚ãÆ----
set channelWideChatHistory(v) {
‚ãÆ----
get blacklistedUsers() {
‚ãÆ----
set blacklistedUsers(v) {
‚ãÆ----
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const CONFIG_DIR = path.join(__dirname, 'config');
const CHAT_HISTORIES_DIR = path.join(CONFIG_DIR, 'chat_histories_4');
export const TEMP_DIR = path.join(__dirname, 'temp');
‚ãÆ----
activeUsersInChannels: path.join(CONFIG_DIR, 'active_users_in_channels.json'),
customInstructions: path.join(CONFIG_DIR, 'custom_instructions.json'),
serverSettings: path.join(CONFIG_DIR, 'server_settings.json'),
userResponsePreference: path.join(CONFIG_DIR, 'user_response_preference.json'),
alwaysRespondChannels: path.join(CONFIG_DIR, 'always_respond_channels.json'),
channelWideChatHistory: path.join(CONFIG_DIR, 'channel_wide_chathistory.json'),
blacklistedUsers: path.join(CONFIG_DIR, 'blacklisted_users.json')
‚ãÆ----
// --- Data Persistence Functions ---
‚ãÆ----
export async function saveStateToFile() {
‚ãÆ----
await fs.mkdir(CONFIG_DIR, {
‚ãÆ----
await fs.mkdir(CHAT_HISTORIES_DIR, {
‚ãÆ----
const chatHistoryPromises = Object.entries(chatHistories).map(([key, value]) => {
const filePath = path.join(CHAT_HISTORIES_DIR, `${key}.json`);
return fs.writeFile(filePath, JSON.stringify(value, null, 2), 'utf-8');
‚ãÆ----
const filePromises = Object.entries(FILE_PATHS).map(([key, filePath]) => {
return fs.writeFile(filePath, JSON.stringify(state[key], null, 2), 'utf-8');
‚ãÆ----
await Promise.all([...chatHistoryPromises, ...filePromises]);
‚ãÆ----
console.error('Error saving state to files:', error);
‚ãÆ----
saveStateToFile();
‚ãÆ----
async function loadStateFromFile() {
‚ãÆ----
await fs.mkdir(TEMP_DIR, {
‚ãÆ----
const files = await fs.readdir(CHAT_HISTORIES_DIR);
‚ãÆ----
.filter(file => file.endsWith('.json'))
.map(async file => {
const user = path.basename(file, '.json');
const filePath = path.join(CHAT_HISTORIES_DIR, file);
‚ãÆ----
const data = await fs.readFile(filePath, 'utf-8');
chatHistories[user] = JSON.parse(data);
‚ãÆ----
console.error(`Error reading chat history for ${user}:`, readError);
‚ãÆ----
await Promise.all(chatHistoryPromises);
const filePromises = Object.entries(FILE_PATHS).map(async ([key, filePath]) => {
‚ãÆ----
state[key] = JSON.parse(data);
‚ãÆ----
console.error(`Error reading ${key} from ${filePath}:`, readError);
‚ãÆ----
await Promise.all(filePromises);
‚ãÆ----
console.error('Error loading state from files:', error);
‚ãÆ----
// --- Daily Cleanup and Initialization ---
function removeFileData(histories) {
‚ãÆ----
Object.values(histories).forEach(subIdEntries => {
subIdEntries.forEach(message => {
‚ãÆ----
message.content = message.content.filter(contentItem => {
‚ãÆ----
return Object.keys(contentItem).length > 0;
‚ãÆ----
console.log('fileData elements have been removed from chat histories.');
‚ãÆ----
console.error('An error occurred while removing fileData elements:', error);
‚ãÆ----
function scheduleDailyReset() {
‚ãÆ----
const now = new Date();
const nextReset = new Date();
nextReset.setHours(0, 0, 0, 0);
‚ãÆ----
nextReset.setDate(now.getDate() + 1);
‚ãÆ----
setTimeout(async () => {
console.log('Running daily cleanup task...');
await chatHistoryLock.runExclusive(async () => {
removeFileData(chatHistories);
await saveStateToFile();
‚ãÆ----
console.log('Daily cleanup task finished.');
scheduleDailyReset();
‚ãÆ----
console.error('An error occurred while scheduling the daily reset:', error);
‚ãÆ----
export async function initialize() {
‚ãÆ----
await loadStateFromFile();
console.log('Bot state loaded and initialized.');
‚ãÆ----
// --- State Helper Functions ---
export function getHistory(id) {
‚ãÆ----
// Combine all message histories for this ID
‚ãÆ----
if (historyObject.hasOwnProperty(messagesId)) {
‚ãÆ----
// Transform to format expected by new Google GenAI API
return combinedHistory.map(entry => {
‚ãÆ----
export function updateChatHistory(id, newHistory, messagesId) {
‚ãÆ----
export function getUserResponsePreference(userId) {
‚ãÆ----
export function initializeBlacklistForGuild(guildId) {
</file>

<file path="commands.js">

</file>

<file path="config.js">

</file>

<file path="index.js">
const storage = new Storage();
‚ãÆ----
initialize().catch(console.error);
// <=====[Configuration]=====>
‚ãÆ----
/*
`BLOCK_NONE`  -  Always show regardless of probability of unsafe content
`BLOCK_ONLY_HIGH`  -  Block when high probability of unsafe content
`BLOCK_MEDIUM_AND_ABOVE`  -  Block when medium or high probability of unsafe content
`BLOCK_LOW_AND_ABOVE`  -  Block when low, medium or high probability of unsafe content
`HARM_BLOCK_THRESHOLD_UNSPECIFIED`  -  Threshold is unspecified, block using default threshold
*/
‚ãÆ----
// maxOutputTokens: 1000,
‚ãÆ----
const activities = config.activities.map(activity => ({
‚ãÆ----
// <==========>
// <=====[Register Commands And Activities]=====>
‚ãÆ----
client.once('clientReady', async () => {
console.log(`Logged in as ${client.user.tag}!`);
const rest = new REST().setToken(token);
‚ãÆ----
console.log('Started refreshing application (/) commands.');
await rest.put(
Routes.applicationCommands(client.user.id), {
‚ãÆ----
console.log('Successfully reloaded application (/) commands.');
‚ãÆ----
console.error(error);
‚ãÆ----
client.user.setPresence({
‚ãÆ----
setInterval(() => {
‚ãÆ----
// <=====[Messages And Interaction]=====>
client.on('messageCreate', async (message) => {
‚ãÆ----
if (message.content.startsWith('!')) return;
‚ãÆ----
(message.mentions.users.has(client.user.id) && !isDM) ||
‚ãÆ----
initializeBlacklistForGuild(message.guild.id);
if (state.blacklistedUsers[message.guild.id].includes(message.author.id)) {
const embed = new EmbedBuilder()
.setColor(0xFF0000)
.setTitle('Blacklisted')
.setDescription('You are blacklisted and cannot use this bot.');
return message.reply({
‚ãÆ----
if (activeRequests.has(message.author.id)) {
‚ãÆ----
.setColor(0xFFFF00)
.setTitle('Request In Progress')
.setDescription('Please wait until your previous action is complete.');
await message.reply({
‚ãÆ----
activeRequests.add(message.author.id);
await handleTextMessage(message);
‚ãÆ----
console.error('Error processing the message:', error);
‚ãÆ----
activeRequests.delete(message.author.id);
‚ãÆ----
client.on('interactionCreate', async (interaction) => {
‚ãÆ----
if (interaction.isChatInputCommand()) {
await handleCommandInteraction(interaction);
} else if (interaction.isButton()) {
await handleButtonInteraction(interaction);
} else if (interaction.isModalSubmit()) {
await handleModalSubmit(interaction);
‚ãÆ----
console.error('Error handling interaction:', error.message);
‚ãÆ----
async function handleCommandInteraction(interaction) {
if (!interaction.isChatInputCommand()) return;
‚ãÆ----
await handler(interaction);
‚ãÆ----
console.log(`Unknown command: ${interaction.commandName}`);
‚ãÆ----
async function handleButtonInteraction(interaction) {
if (!interaction.isButton()) return;
‚ãÆ----
initializeBlacklistForGuild(interaction.guild.id);
if (state.blacklistedUsers[interaction.guild.id].includes(interaction.user.id)) {
‚ãÆ----
.setDescription('You are blacklisted and cannot use this interaction.');
return interaction.reply({
‚ãÆ----
for (const [key, handler] of Object.entries(buttonHandlers)) {
if (interaction.customId.startsWith(key)) {
‚ãÆ----
if (interaction.customId.startsWith('delete_message-')) {
const msgId = interaction.customId.replace('delete_message-', '');
await handleDeleteMessageInteraction(interaction, msgId);
‚ãÆ----
async function handleDeleteMessageInteraction(interaction, msgId) {
‚ãÆ----
const message = channel ? (await channel.messages.fetch(msgId).catch(() => false)) : false;
‚ãÆ----
await deleteMsg();
‚ãÆ----
const replyingTo = message ? (message.reference ? (await message.channel.messages.fetch(message.reference.messageId)).author.id : 0) : 0;
‚ãÆ----
.setTitle('Not For You')
.setDescription('This button is not meant for you.');
‚ãÆ----
async function deleteMsg() {
await interaction.message.delete()
.catch('Error deleting interaction message: ', console.error);
‚ãÆ----
message.delete().catch(() => { });
‚ãÆ----
async function handleClearMemoryCommand(interaction) {
‚ãÆ----
// This is the original safety check. If server-wide history is on, we stop here.
‚ãÆ----
.setColor(0xFF5555)
.setTitle('Feature Disabled')
.setDescription('Clearing chat history is not enabled for this server, as Server-Wide chat history is active.');
await interaction.reply({
‚ãÆ----
// Server-wide history is OFF, so we can proceed with the confirmation flow.
// First, check if there's any personal history to clear.
‚ãÆ----
return await interaction.reply({ content: 'You have no personal chat history to clear.', ephemeral: true });
‚ãÆ----
// 1. Create the confirmation buttons.
const confirmButton = new ButtonBuilder()
.setCustomId('confirm_clear')
.setLabel('Yes, clear it')
.setStyle(ButtonStyle.Danger); // Red for a destructive action.
const cancelButton = new ButtonBuilder()
.setCustomId('cancel_clear')
.setLabel('No, cancel')
.setStyle(ButtonStyle.Secondary); // Grey for a safe action.
// 2. Create an action row to hold the buttons.
const row = new ActionRowBuilder()
.addComponents(confirmButton, cancelButton);
// 3. Send the confirmation message with the buttons.
const confirmationMessage = await interaction.reply({
‚ãÆ----
ephemeral: true // Only the user who ran the command will see this.
‚ãÆ----
// 4. Create a collector to listen for a button click from only this user.
const filter = i => i.user.id === userId;
const collector = confirmationMessage.createMessageComponentCollector({ filter, time: 60000 }); // Wait for 60 seconds.
collector.on('collect', async i => {
‚ãÆ----
// If "Yes" is clicked, clear the memory.
‚ãÆ----
await saveStateToFile();
// Update the message to show success and remove the buttons.
await i.update({ content: 'Your personal chat history has been cleared.', components: [] });
‚ãÆ----
// If "No" is clicked, cancel the action.
await i.update({ content: 'Action canceled. Your chat history was not cleared.', components: [] });
‚ãÆ----
collector.on('end', collected => {
// This runs after the 60-second timer is up.
‚ãÆ----
// If no button was clicked, edit the message to show it timed out.
interaction.editReply({ content: 'Confirmation timed out. Your chat history was not cleared.', components: [] });
‚ãÆ----
async function handleCustomPersonalityCommand(interaction) {
‚ãÆ----
await setCustomPersonality(interaction);
‚ãÆ----
.setDescription('Custom personality is not enabled for this server, Server-Wide personality is active.');
‚ãÆ----
async function handleRemovePersonalityCommand(interaction) {
‚ãÆ----
await removeCustomPersonality(interaction);
‚ãÆ----
async function handleToggleResponseMode(interaction) {
‚ãÆ----
await toggleUserResponsePreference(interaction);
‚ãÆ----
.setDescription('Toggling Response Mode is not enabled for this server, Server-Wide Response Mode is active.');
‚ãÆ----
async function editShowSettings(interaction) {
await showSettings(interaction, true);
‚ãÆ----
// <=====[Messages Handling]=====>
async function handleTextMessage(message) {
‚ãÆ----
let messageContent = message.content.replace(new RegExp(`<@!?${botId}>`), '').trim();
if (messageContent === '' && !(message.attachments.size > 0 && hasSupportedAttachments(message))) {
if (activeRequests.has(userId)) {
activeRequests.delete(userId);
‚ãÆ----
.setColor(0x00FFFF)
.setTitle('Empty Message')
.setDescription("It looks like you didn't say anything. What would you like to talk about?");
const botMessage = await message.reply({
‚ãÆ----
await addSettingsButton(botMessage);
‚ãÆ----
message.channel.sendTyping();
const typingInterval = setInterval(() => {
‚ãÆ----
setTimeout(() => {
clearInterval(typingInterval);
‚ãÆ----
const updateEmbedDescription = (textAttachmentStatus, imageAttachmentStatus, finalText) => {
‚ãÆ----
.setTitle('Processing')
.setDescription(updateEmbedDescription('[üîÅ]', '[üîÅ]'));
botMessage = await message.reply({
‚ãÆ----
messageContent = await extractFileText(message, messageContent);
embed.setDescription(updateEmbedDescription('[‚òëÔ∏è]', '[üîÅ]'));
await botMessage.edit({
‚ãÆ----
parts = await processPromptAndMediaAttachments(messageContent, message);
embed.setDescription(updateEmbedDescription('[‚òëÔ∏è]', '[‚òëÔ∏è]', '### All checks done. Waiting for the response...'));
‚ãÆ----
return console.error('Error initialising message', error);
‚ãÆ----
// --- NEW LOGIC TO CROSS-REFERENCE CONVERSATIONS & INSTRUCTIONS (v4) ---
const mentionedUser = message.mentions.users.find(user => !user.bot);
‚ãÆ----
console.log(`Referenced user detected: ${mentionedUser.username} (ID: ${mentionedUser.id})`);
// --- CHAT HISTORY LOOKUP ---
const otherUserHistory = getHistory(mentionedUser.id);
‚ãÆ----
// TRUNCATION: Only take the last 20 messages from the other user's history.
‚ãÆ----
const truncatedHistory = otherUserHistory.slice(-RECENT_MESSAGES_LIMIT);
const historyText = truncatedHistory.map(h => {
const content = h.parts?.map(p => p.text).join(' ') || '';
‚ãÆ----
}).join('\n');
‚ãÆ----
parts.unshift(historyContextPart);
console.log(`Successfully loaded and prepended the last ${truncatedHistory.length} messages for ${mentionedUser.username}.`);
‚ãÆ----
console.log(`No chat history found via getHistory() for the mentioned user: ${mentionedUser.username}`);
‚ãÆ----
// --- PERSONALITY INSTRUCTIONS LOOKUP (This part is correct) ---
‚ãÆ----
if (personalityInstructions && personalityInstructions.trim() !== '') {
‚ãÆ----
parts.unshift(instructionContextPart);
console.log(`Successfully loaded and prepended personality instructions for ${mentionedUser.username}.`);
‚ãÆ----
console.log(`No custom instructions found for the mentioned user: ${mentionedUser.username}`);
‚ãÆ----
// --- END OF NEW LOGIC ---
‚ãÆ----
// --- NEW LOGIC TO PREPEND DEFAULT PERSONALITY ---
// 1. Start with the base defaultPersonality as the foundation for all interactions.
‚ãÆ----
// 2. If custom instructions exist (from user, channel, or server settings), append them.
‚ãÆ----
// 3. Append server and user info if applicable, just like before.
‚ãÆ----
// This part of the logic remains the same.
‚ãÆ----
// Always enable all three tools: Google Search, URL Context, and Code Execution.
‚ãÆ----
//Disabled Code execution for now as it crashes the system.
‚ãÆ----
// Create chat with new Google GenAI API format
‚ãÆ----
const chat = genAI.chats.create({
‚ãÆ----
parts: [{ text: finalInstructions }] // The fallback is no longer needed.
‚ãÆ----
history: getHistory(historyId)
‚ãÆ----
await handleModelResponse(botMessage, chat, parts, message, typingInterval, historyId, mentionedUser);
‚ãÆ----
function hasSupportedAttachments(message) {
‚ãÆ----
return message.attachments.some((attachment) => {
const contentType = (attachment.contentType || "").toLowerCase();
const fileExtension = path.extname(attachment.name) || '';
‚ãÆ----
(contentType.startsWith('image/') && contentType !== 'image/gif') ||
contentType.startsWith('audio/') ||
contentType.startsWith('video/') ||
contentType.startsWith('application/pdf') ||
contentType.startsWith('application/x-pdf') ||
supportedFileExtensions.includes(fileExtension)
‚ãÆ----
async function downloadFile(url, filePath) {
const writer = createWriteStream(filePath);
const response = await axios({
‚ãÆ----
response.data.pipe(writer);
return new Promise((resolve, reject) => {
writer.on('finish', resolve);
writer.on('error', reject);
‚ãÆ----
function sanitizeFileName(fileName) {
‚ãÆ----
.toLowerCase()
.replace(/[^a-z0-9-]/g, '-')
.replace(/^-+|-+$/g, '');
‚ãÆ----
async function processPromptAndMediaAttachments(prompt, message) {
const attachments = JSON.parse(JSON.stringify(Array.from(message.attachments.values())));
‚ãÆ----
const validAttachments = attachments.filter(attachment => {
‚ãÆ----
return (contentType.startsWith('image/') && contentType !== 'image/gif') ||
‚ãÆ----
contentType.startsWith('application/x-pdf');
‚ãÆ----
const attachmentParts = await Promise.all(
validAttachments.map(async (attachment) => {
const sanitizedFileName = sanitizeFileName(attachment.name);
‚ãÆ----
const filePath = path.join(TEMP_DIR, uniqueTempFilename);
‚ãÆ----
// This part is correct, it downloads the file to a temporary location.
await downloadFile(attachment.url, filePath);
// --- NEW GCS UPLOAD LOGIC STARTS HERE ---
// Define a unique name for the file in the GCS bucket.
const gcsFileName = `${Date.now()}-${sanitizedFileName}`;
// Upload the local file from the temp directory to your GCS bucket.
await storage.bucket(BUCKET_NAME).upload(filePath, {
‚ãÆ----
// Construct the GCS URI that Vertex AI needs.
‚ãÆ----
// Return the object structure that the Vertex AI API expects for a file.
// This replaces the old `createPartFromUri` function call.
‚ãÆ----
console.error(`Error processing attachment ${sanitizedFileName}:`, error);
‚ãÆ----
// This original cleanup logic is perfect and ensures the temporary local file is deleted.
‚ãÆ----
await fs.unlink(filePath);
‚ãÆ----
console.error(`Error deleting temporary file ${filePath}:`, unlinkError);
‚ãÆ----
parts = [...parts, ...attachmentParts.filter(part => part !== null)];
‚ãÆ----
async function extractFileText(message, messageContent) {
‚ãÆ----
let attachments = Array.from(message.attachments.values());
‚ãÆ----
const fileType = path.extname(attachment.name) || '';
‚ãÆ----
if (fileTypes.includes(fileType)) {
‚ãÆ----
let fileContent = await downloadAndReadFile(attachment.url, fileType);
‚ãÆ----
console.error(`Error reading file ${attachment.name}: ${error.message}`);
‚ãÆ----
async function downloadAndReadFile(url, fileType) {
‚ãÆ----
const extractor = getTextExtractor();
return (await extractor.extractText({
‚ãÆ----
const response = await fetch(url);
if (!response.ok) throw new Error(`Failed to download ${response.statusText}`);
return await response.text();
‚ãÆ----
// <=====[Interaction Reply]=====>
async function handleModalSubmit(interaction) {
‚ãÆ----
const customInstructionsInput = interaction.fields.getTextInputValue('custom-personality-input');
state.customInstructions[interaction.user.id] = customInstructionsInput.trim();
‚ãÆ----
.setColor(0x00FF00)
.setTitle('Success')
.setDescription('Custom Personality Instructions Saved!');
‚ãÆ----
console.log(error.message);
‚ãÆ----
const customInstructionsInput = interaction.fields.getTextInputValue('custom-server-personality-input');
state.customInstructions[interaction.guild.id] = customInstructionsInput.trim();
‚ãÆ----
.setDescription('Custom Server Personality Instructions Saved!');
‚ãÆ----
async function clearChatHistory(interaction) {
‚ãÆ----
.setTitle('Chat History Cleared')
.setDescription('Chat history cleared!');
‚ãÆ----
async function alwaysRespond(interaction) {
‚ãÆ----
const dmDisabledEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Feature Disabled in DMs')
.setDescription('This feature is disabled in direct messages.');
‚ãÆ----
await handleSubButtonInteraction(interaction, true);
‚ãÆ----
async function handleRespondToAllCommand(interaction) {
‚ãÆ----
const dmEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Command Not Available')
.setDescription('This command cannot be used in DMs.');
‚ãÆ----
if (!interaction.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
const adminEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Admin Required')
.setDescription('You need to be an admin to use this command.');
‚ãÆ----
const enabled = interaction.options.getBoolean('enabled');
‚ãÆ----
const startRespondEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Bot Response Enabled')
.setDescription('The bot will now respond to all messages in this channel.');
‚ãÆ----
const stopRespondEmbed = new EmbedBuilder()
.setColor(0xFFA500)
.setTitle('Bot Response Disabled')
.setDescription('The bot will now stop responding to all messages in this channel.');
‚ãÆ----
async function toggleChannelChatHistory(interaction) {
‚ãÆ----
const instructions = interaction.options.getString('instructions') || defaultPersonality;
‚ãÆ----
const enabledEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Channel History Enabled')
.setDescription(`Channel-wide chat history has been enabled.`);
‚ãÆ----
const disabledEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Channel History Disabled')
.setDescription('Channel-wide chat history has been disabled.');
‚ãÆ----
console.error('Error in toggleChannelChatHistory:', error);
‚ãÆ----
async function handleStatusCommand(interaction) {
‚ãÆ----
await interaction.deferReply();
‚ãÆ----
const updateMessage = async () => {
‚ãÆ----
}, cpuPercentage] = await Promise.all([
mem.info(),
cpu.usage()
‚ãÆ----
const now = new Date();
const nextReset = new Date();
nextReset.setHours(0, 0, 0, 0);
‚ãÆ----
nextReset.setDate(now.getDate() + 1);
‚ãÆ----
const hours = Math.floor(timeLeftMillis / 3600000);
const minutes = Math.floor((timeLeftMillis % 3600000) / 60000);
const seconds = Math.floor((timeLeftMillis % 60000) / 1000);
‚ãÆ----
.setColor(hexColour)
.setTitle('System Information')
.addFields({
‚ãÆ----
.setTimestamp();
await interaction.editReply({
‚ãÆ----
console.error('Error updating message:', error);
if (interval) clearInterval(interval);
‚ãÆ----
await updateMessage();
const message = await interaction.fetchReply();
await addSettingsButton(message);
interval = setInterval(updateMessage, 2000);
‚ãÆ----
clearInterval(interval);
‚ãÆ----
console.error('Error in handleStatusCommand function:', error);
‚ãÆ----
async function handleBlacklistCommand(interaction) {
‚ãÆ----
const userId = interaction.options.getUser('user').id;
‚ãÆ----
initializeBlacklistForGuild(guildId);
if (!state.blacklistedUsers[guildId].includes(userId)) {
state.blacklistedUsers[guildId].push(userId);
const blacklistedEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('User Blacklisted')
.setDescription(`<@${userId}> has been blacklisted.`);
‚ãÆ----
const alreadyBlacklistedEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('User Already Blacklisted')
.setDescription(`<@${userId}> is already blacklisted.`);
‚ãÆ----
async function handleWhitelistCommand(interaction) {
‚ãÆ----
const index = state.blacklistedUsers[guildId].indexOf(userId);
‚ãÆ----
state.blacklistedUsers[guildId].splice(index, 1);
const removedEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('User Whitelisted')
.setDescription(`<@${userId}> has been removed from the blacklist.`);
‚ãÆ----
const notFoundEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('User Not Found')
.setDescription(`<@${userId}> is not in the blacklist.`);
‚ãÆ----
async function setCustomPersonality(interaction) {
‚ãÆ----
const input = new TextInputBuilder()
.setCustomId(customId)
.setLabel("What should the bot's personality be like?")
.setStyle(TextInputStyle.Paragraph)
.setPlaceholder("Enter the custom instructions here...")
.setMinLength(10)
.setMaxLength(4000);
const modal = new ModalBuilder()
.setCustomId('custom-personality-modal')
.setTitle(title)
.addComponents(new ActionRowBuilder().addComponents(input));
await interaction.showModal(modal);
‚ãÆ----
async function downloadMessage(interaction) {
‚ãÆ----
const emptyEmbed = new EmbedBuilder()
‚ãÆ----
.setDescription('The message is empty..?');
‚ãÆ----
const filePath = path.join(TEMP_DIR, `message_content_${interaction.id}.txt`);
await fs.writeFile(filePath, textContent, 'utf8');
const attachment = new AttachmentBuilder(filePath, {
‚ãÆ----
const initialEmbed = new EmbedBuilder()
.setColor(0xFFFFFF)
.setTitle('Message Content Downloaded')
.setDescription(`Here is the content of the message.`);
‚ãÆ----
response = await interaction.reply({
‚ãÆ----
response = await interaction.user.send({
‚ãÆ----
const dmSentEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Content Sent')
.setDescription('The message content has been sent to your DMs.');
‚ãÆ----
console.error(`Failed to send DM: ${error}`);
const failDMEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Delivery Failed')
.setDescription('Failed to send the content to your DMs.');
‚ãÆ----
const msgUrl = await uploadText(textContent);
const updatedEmbed = EmbedBuilder.from(response.embeds[0])
.setDescription(`Here is the content of the message.\n${msgUrl}`);
‚ãÆ----
await response.edit({
‚ãÆ----
console.log('Failed to process download: ', error);
‚ãÆ----
const uploadText = async (text) => {
‚ãÆ----
const response = await axios.post(`${siteUrl}/api/text`, {
‚ãÆ----
console.log(error);
‚ãÆ----
async function downloadConversation(interaction) {
‚ãÆ----
const conversationHistory = getHistory(userId);
‚ãÆ----
const noHistoryEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('No History Found')
.setDescription('No conversation history found.');
‚ãÆ----
let conversationText = conversationHistory.map(entry => {
‚ãÆ----
const content = entry.parts.map(c => c.text).join('\n');
‚ãÆ----
}).join('');
const tempFileName = path.join(TEMP_DIR, `conversation_${interaction.id}.txt`);
await fs.writeFile(tempFileName, conversationText, 'utf8');
const file = new AttachmentBuilder(tempFileName, {
‚ãÆ----
await interaction.user.send({
‚ãÆ----
.setTitle('History Sent')
.setDescription('Your conversation history has been sent to your DMs.');
‚ãÆ----
.setDescription('Failed to send the conversation history to your DMs.');
‚ãÆ----
await fs.unlink(tempFileName);
‚ãÆ----
console.log(`Failed to download conversation: ${error.message}`);
‚ãÆ----
async function removeCustomPersonality(interaction) {
‚ãÆ----
.setTitle('Removed')
.setDescription('Custom personality instructions removed!');
‚ãÆ----
async function toggleUserResponsePreference(interaction) {
‚ãÆ----
const currentPreference = getUserResponsePreference(userId);
‚ãÆ----
async function toggleServerWideChatHistory(interaction) {
‚ãÆ----
.setTitle('Server Command Only')
.setDescription('This command can only be used in a server.');
‚ãÆ----
initializeBlacklistForGuild(serverId);
‚ãÆ----
.setColor(state.serverSettings[serverId].serverChatHistory ? 0x00FF00 : 0xFF0000)
.setTitle('Chat History Toggled')
.setDescription(statusMessage + warningMessage);
‚ãÆ----
console.log('Error toggling server-wide chat history:', error.message);
‚ãÆ----
async function toggleServerPersonality(interaction) {
‚ãÆ----
.setColor(state.serverSettings[serverId].customServerPersonality ? 0x00FF00 : 0xFF0000)
.setTitle('Server Personality Toggled')
.setDescription(statusMessage);
‚ãÆ----
console.log('Error toggling server-wide personality:', error.message);
‚ãÆ----
async function toggleServerResponsePreference(interaction) {
‚ãÆ----
.setColor(state.serverSettings[serverId].serverResponsePreference ? 0x00FF00 : 0xFF0000)
.setTitle('Server Response Preference Toggled')
‚ãÆ----
console.log('Error toggling server-wide response preference:', error.message);
‚ãÆ----
async function toggleSettingSaveButton(interaction) {
‚ãÆ----
.setColor(state.serverSettings[serverId].settingsSaveButton ? 0x00FF00 : 0xFF0000)
.setTitle('Settings Save Button Toggled')
‚ãÆ----
console.log('Error toggling server-wide settings save button:', error.message);
‚ãÆ----
async function serverPersonality(interaction) {
‚ãÆ----
.setCustomId('custom-server-personality-modal')
‚ãÆ----
async function clearServerChatHistory(interaction) {
‚ãÆ----
const clearedEmbed = new EmbedBuilder()
‚ãÆ----
.setDescription('Server-wide chat history cleared!');
‚ãÆ----
.setDescription('Server-wide chat history is disabled for this server.');
‚ãÆ----
console.log('Failed to clear server-wide chat history:', error.message);
‚ãÆ----
async function downloadServerConversation(interaction) {
‚ãÆ----
const conversationHistory = getHistory(guildId);
‚ãÆ----
.setDescription('No server-wide conversation history found.');
‚ãÆ----
const conversationText = conversationHistory.map(entry => {
‚ãÆ----
const tempFileName = path.join(TEMP_DIR, `server_conversation_${interaction.id}.txt`);
‚ãÆ----
.setDescription('Server-wide conversation history has been sent to your DMs.');
‚ãÆ----
.setDescription('Failed to send the server-wide conversation history to your DMs.');
‚ãÆ----
console.log(`Failed to download server conversation: ${error.message}`);
‚ãÆ----
async function toggleServerPreference(interaction) {
‚ãÆ----
.setTitle('Server Response Style Updated')
.setDescription(`Server response style updated to: ${state.serverSettings[guildId].responseStyle}`);
‚ãÆ----
async function showSettings(interaction, edit = false) {
‚ãÆ----
const mainButtonsComponents = mainButtons.map(config =>
new ButtonBuilder()
.setCustomId(config.customId)
.setLabel(config.label)
.setEmoji(config.emoji)
.setStyle(config.style)
‚ãÆ----
const mainActionRow = new ActionRowBuilder().addComponents(...mainButtonsComponents);
‚ãÆ----
.setTitle('Settings')
.setDescription('Please choose a category from the buttons below:');
‚ãÆ----
await interaction.update({
‚ãÆ----
console.error('Error showing settings:', error.message);
‚ãÆ----
async function handleSubButtonInteraction(interaction, update = false) {
‚ãÆ----
const responseMode = getUserResponsePreference(userId);
‚ãÆ----
const subButtons = subButtonConfigs[update ? 'general-settings' : interaction.customId].map(config =>
‚ãÆ----
actionRows.push(new ActionRowBuilder().addComponents(subButtons.splice(0, 5)));
‚ãÆ----
new EmbedBuilder()
‚ãÆ----
.setTitle(`${update ? 'General Settings' : interaction.customId.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}`)
.setDescription('Please choose an option from the buttons below:'),
‚ãÆ----
async function showDashboard(interaction) {
‚ãÆ----
.setTitle('Command Restricted')
‚ãÆ----
.setTitle('Administrator Required')
‚ãÆ----
const allButtons = buttonConfigs.map((config) =>
‚ãÆ----
actionRows.push(
new ActionRowBuilder().addComponents(allButtons.splice(0, 5))
‚ãÆ----
.setDescription('Your Server Settings:');
‚ãÆ----
// <=====[Others]=====>
async function addDownloadButton(botMessage) {
‚ãÆ----
const downloadButton = new ButtonBuilder()
.setCustomId('download_message')
.setLabel('Save')
.setEmoji('‚¨áÔ∏è')
.setStyle(ButtonStyle.Secondary);
‚ãÆ----
actionRow = ActionRowBuilder.from(messageComponents[0]);
‚ãÆ----
actionRow = new ActionRowBuilder();
‚ãÆ----
actionRow.addComponents(downloadButton);
return await botMessage.edit({
‚ãÆ----
console.error('Error adding download button:', error.message);
‚ãÆ----
async function addDeleteButton(botMessage, msgId) {
‚ãÆ----
.setCustomId(`delete_message-${msgId}`)
.setLabel('Delete')
.setEmoji('üóëÔ∏è')
‚ãÆ----
console.error('Error adding delete button:', error.message);
‚ãÆ----
async function addSettingsButton(botMessage) {
‚ãÆ----
const settingsButton = new ButtonBuilder()
.setCustomId('settings')
.setEmoji('‚öôÔ∏è')
‚ãÆ----
const actionRow = new ActionRowBuilder().addComponents(settingsButton);
‚ãÆ----
console.log('Error adding settings button:', error.message);
‚ãÆ----
// <=====[Model Response Handling]=====>
async function handleModelResponse(initialBotMessage, chat, parts, originalMessage, typingInterval, historyId, mentionedUser) {
‚ãÆ----
const userResponsePreference = originalMessage.guild && state.serverSettings[originalMessage.guild.id]?.serverResponsePreference ? state.serverSettings[originalMessage.guild.id].responseStyle : getUserResponsePreference(userId);
‚ãÆ----
// Metadata from Google Search with URL Context tool
‚ãÆ----
const stopGeneratingButton = new ActionRowBuilder()
.addComponents(
‚ãÆ----
.setCustomId('stopGenerating')
.setLabel('Stop Generating')
.setStyle(ButtonStyle.Danger)
‚ãÆ----
botMessage = await originalMessage.reply({
‚ãÆ----
botMessage.edit({
‚ãÆ----
const filter = (interaction) => interaction.customId === 'stopGenerating';
‚ãÆ----
const collector = await botMessage.createMessageComponentCollector({
‚ãÆ----
collector.on('collect', (interaction) => {
‚ãÆ----
.setTitle('Response Stopped')
.setDescription('Response generation stopped by the user.');
interaction.reply({
‚ãÆ----
console.error('Error sending reply:', error);
‚ãÆ----
.setTitle('Access Denied')
.setDescription("It's not for you.");
‚ãÆ----
console.error('Error sending unauthorized reply:', error);
‚ãÆ----
console.error('Error creating or handling collector:', error);
‚ãÆ----
const updateMessage = () => {
‚ãÆ----
if (tempResponse.trim() === "") {
‚ãÆ----
updateEmbed(botMessage, tempResponse, originalMessage, groundingMetadata, urlContextMetadata);
‚ãÆ----
// Add a safety check to prevent crashing on long streaming updates
‚ãÆ----
clearTimeout(updateTimeout);
‚ãÆ----
// --- NEW LOGIC TO CREATE PLACEHOLDER FOR SAVED HISTORY ---
// Create a clean version of the user's prompt for saving.
const userPartsForHistory = parts.map(part => {
// Check if this part is one of our special context blocks.
if (part.text && part.text.includes('--- Additional Context')) {
// If it is, replace it with a simple placeholder string.
‚ãÆ----
// Otherwise, keep the original part (the user's actual message).
‚ãÆ----
}).filter((part, index, self) =>
// Remove duplicate placeholders if both history and instructions were found.
index === self.findIndex(p => p.text === part.text)
‚ãÆ----
newHistory.push({
‚ãÆ----
async function getResponse(parts) {
‚ãÆ----
const messageResult = await chat.sendMessageStream({
‚ãÆ----
// Capture grounding metadata from Google Search with URL Context tool
‚ãÆ----
// Capture URL context metadata from Google Search with URL Context tool
‚ãÆ----
.setTitle('Response Overflow')
.setDescription('The response got too large, will be sent as a text file once it is completed.');
‚ãÆ----
updateTimeout = setTimeout(updateMessage, 500);
‚ãÆ----
await getResponse(parts);
// Final update to ensure grounding and URL context metadata is displayed in embedded responses
‚ãÆ----
updateEmbed(botMessage, finalResponse, originalMessage, groundingMetadata, urlContextMetadata);
‚ãÆ----
botMessage = await addSettingsButton(botMessage);
‚ãÆ----
sendAsTextFile(finalResponse, originalMessage, botMessage.id);
botMessage = await addDeleteButton(botMessage, botMessage.id);
‚ãÆ----
botMessage = await addDownloadButton(botMessage);
‚ãÆ----
await chatHistoryLock.runExclusive(async () => {
updateChatHistory(historyId, newHistory, botMessage.id);
‚ãÆ----
console.error('Generation Attempt Failed: ', error);
‚ãÆ----
.setTitle('Generation Failure')
.setDescription(`All Generation Attempts Failed :(\n\`\`\`${error.message}\`\`\``);
const errorMsg = await originalMessage.channel.send({
‚ãÆ----
await addSettingsButton(errorMsg);
‚ãÆ----
const simpleErrorEmbed = new EmbedBuilder()
‚ãÆ----
.setTitle('Bot Overloaded')
.setDescription('Something seems off, the bot might be overloaded! :(');
‚ãÆ----
embeds: [new EmbedBuilder()
‚ãÆ----
.setTitle('Retry in Progress')
.setDescription(`Generation Attempt(s) Failed, Retrying..\n\`\`\`${error.message}\`\`\``)
‚ãÆ----
setTimeout(() => errorMsg.delete().catch(console.error), 5000);
await delay(500);
‚ãÆ----
function updateEmbed(botMessage, finalResponse, message, groundingMetadata = null, urlContextMetadata = null) {
‚ãÆ----
.setDescription(finalResponse)
.setAuthor({
‚ãÆ----
iconURL: message.author.displayAvatarURL()
‚ãÆ----
// Add grounding metadata if user has Google Search tool enabled and Embedded responses selected
if (groundingMetadata && shouldShowGroundingMetadata(message)) {
addGroundingMetadataToEmbed(embed, groundingMetadata);
‚ãÆ----
// Add URL context metadata if user has Google Search tool enabled and Embedded responses selected
if (urlContextMetadata && shouldShowGroundingMetadata(message)) {
addUrlContextMetadataToEmbed(embed, urlContextMetadata);
‚ãÆ----
embed.setFooter({
‚ãÆ----
iconURL: message.guild.iconURL() || 'https://ai.google.dev/static/site-assets/images/share.png'
‚ãÆ----
console.error("An error occurred while updating the embed:", error.message);
‚ãÆ----
function addGroundingMetadataToEmbed(embed, groundingMetadata) {
// Add search queries used by the model
‚ãÆ----
embed.addFields({
‚ãÆ----
value: groundingMetadata.webSearchQueries.map(query => `‚Ä¢ ${query}`).join('\n'),
‚ãÆ----
// Add grounding sources with clickable links
‚ãÆ----
.slice(0, 5) // Limit to first 5 chunks to avoid embed limits
.map((chunk, index) => {
‚ãÆ----
.join('\n');
‚ãÆ----
function addUrlContextMetadataToEmbed(embed, urlContextMetadata) {
// Add URL retrieval status with success/failure indicators
‚ãÆ----
.map(urlData => {
‚ãÆ----
function shouldShowGroundingMetadata(message) {
// Tools are always enabled; only show when user prefers Embedded responses
‚ãÆ----
: getUserResponsePreference(userId);
‚ãÆ----
async function sendAsTextFile(text, message, orgId) {
‚ãÆ----
const filename = `response-${Date.now()}.txt`;
const tempFilePath = path.join(TEMP_DIR, filename);
await fs.writeFile(tempFilePath, text);
const botMessage = await message.channel.send({
‚ãÆ----
await addDeleteButton(botMessage, orgId);
await fs.unlink(tempFilePath);
‚ãÆ----
console.error('An error occurred:', error);
‚ãÆ----
client.login(token);
</file>

<file path="package.json">
{
  "type": "module",
  "dependencies": {
    "@google-cloud/storage": "^7.17.1",
    "@google/genai": "*",
    "axios": "*",
    "discord.js": "*",
    "dotenv": "*",
    "fs": "*",
    "node-os-utils": "*",
    "office-text-extractor": "*",
    "sharp": "*"
  },
  "scripts": {
    "start": "node index.js"
  }
}
</file>

</files>